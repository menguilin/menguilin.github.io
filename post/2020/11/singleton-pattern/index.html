<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>设计模式之单例模式 - menguilin's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="menguilin"><meta name=description content="定义 单例模式保证了一个类只有一个实例，并且提供了全局唯一的访问方式。 核心 单例模式主要是将构造方法私有化，防止其他线程创建新的实例。 实现方式 饿"><meta name=keywords content="menguilin,blog,java"><meta name=generator content="Hugo 0.83.1 with theme even"><link rel=canonical href=https://guilin.men/post/2020/11/singleton-pattern/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.154ed883776547b0e136be39b3037f61350da06f888d0868d1756a9463cd9520.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="设计模式之单例模式"><meta property="og:description" content="定义 单例模式保证了一个类只有一个实例，并且提供了全局唯一的访问方式。 核心 单例模式主要是将构造方法私有化，防止其他线程创建新的实例。 实现方式 饿"><meta property="og:type" content="article"><meta property="og:url" content="https://guilin.men/post/2020/11/singleton-pattern/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-11-28T05:41:57+08:00"><meta property="article:modified_time" content="2020-11-28T05:41:57+08:00"><meta itemprop=name content="设计模式之单例模式"><meta itemprop=description content="定义 单例模式保证了一个类只有一个实例，并且提供了全局唯一的访问方式。 核心 单例模式主要是将构造方法私有化，防止其他线程创建新的实例。 实现方式 饿"><meta itemprop=datePublished content="2020-11-28T05:41:57+08:00"><meta itemprop=dateModified content="2020-11-28T05:41:57+08:00"><meta itemprop=wordCount content="2898"><meta itemprop=keywords content="设计模式,单例模式,"><meta name=twitter:card content="summary"><meta name=twitter:title content="设计模式之单例模式"><meta name=twitter:description content="定义 单例模式保证了一个类只有一个实例，并且提供了全局唯一的访问方式。 核心 单例模式主要是将构造方法私有化，防止其他线程创建新的实例。 实现方式 饿"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>设计模式之单例模式</h1><div class=post-meta><span class=post-time>2020-11-28</span><div class=post-category><a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><span class=more-meta>约 2898 字</span>
<span class=more-meta>预计阅读 6 分钟</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#定义>定义</a></li><li><a href=#核心>核心</a></li><li><a href=#实现方式>实现方式</a><ul><li><a href=#饿汉式>饿汉式</a></li><li><a href=#懒汉式>懒汉式</a></li><li><a href=#双重检查模式dcl>双重检查模式(DCL)</a></li><li><a href=#静态内部类>静态内部类</a></li><li><a href=#枚举式>枚举式</a></li></ul></li><li><a href=#引申>引申</a><ul><li><a href=#python>python</a></li><li><a href=#kotlin>kotlin</a></li><li><a href=#js>js</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=定义>定义</h2><p>单例模式保证了一个类只有一个实例，并且提供了全局唯一的访问方式。</p><h2 id=核心>核心</h2><p>单例模式主要是将构造方法私有化，防止其他线程创建新的实例。</p><h2 id=实现方式>实现方式</h2><h3 id=饿汉式>饿汉式</h3><p>饿汉式，就是直接创建好对象，缺点就是浪费内存空间，尤其对于jvm来说，过多的对象会造成频繁的fullgc。实现代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span><span style=color:#f92672>()</span> <span style=color:#f92672>{}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>所以我们能不能在只需要对象的时候才创建呢？有饱必有饿，接下来看懒汉式。</p><h3 id=懒汉式>懒汉式</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton instance<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span><span style=color:#f92672>()</span> <span style=color:#f92672>{}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>懒汉式是最简单的实现，也符合我们一般思考方式，在Java中多线程是基本要求，所以我们需要实现线程安全的懒汉式写法，最简单实现是在getInstance方法上加synchronized锁，或者是:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>Singleton<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>   
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>但是这种写法存在很严重的问题，每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。所以只有在对象不存在的时候才会加锁去创建对象，其实就是下面的DCL双重检查模式。</p><h3 id=双重检查模式dcl>双重检查模式(DCL)</h3><p>双重检查其实就是在加锁前后进行判断，当对象为空的时候创建对象。需要特别注意的是静态属性要加上volatile保证加锁的时候能够及时写入缓存，保证其他线程拿到的是最新的对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>static</span> Singleton instance<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span><span style=color:#f92672>()</span> <span style=color:#f92672>{}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>Singleton<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>   
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>双重检查模式即能保证了线程安全又能节约内存。双重检查模式写起来比较复杂，能否简化呢？虽然java语法很繁琐，但是答案还是肯定的。接下来的静态内部类和枚举方式是实现比较优雅的方式。</p><h3 id=静态内部类>静态内部类</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span><span style=color:#f92672>(){}</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingletonHoler</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton INSTANCE <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>return</span> SingletonHoler<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>静态内部类的效果和双重检查模式差不多，但是实现上更简单。当Singleton第一次被加载时，并不需要去加载SingletonHoler，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE, 第一次调用getInstance()方法会导致虚拟机加载SingletonHoler类，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。那么静态内部类是如何实现线程安全的呢？我们来看下类加载的方式：</p><p>JAVA虚拟机在有且仅有的5种场景下会对类进行初始化。</p><ul><li>遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，对应的java代码场景为：new一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li><li>当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。</li><li>当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke. MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><p>这5种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是"有且仅有"，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。那instance的创建过程是如何保证线程安全的呢？在《深入理解JAVA虚拟机》中，有这么一句话:</p><blockquote><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p></blockquote><p>故而，可以看出INSTANCE在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p><p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，我们创建单例时，可以在静态内部类与DCL模式里自己斟酌。</p><h3 id=枚举式>枚举式</h3><p>枚举式是比较新的写法，在jdk1.5后支持，这种写法简单明了，并且无需关心多线程问题。枚举式还有个特别的优点就是反序列化也不会新创建对象，这点在前面的方式都不能方便的支持。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Singleton <span style=color:#f92672>{</span>
    INTSTANCE<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>anyMethod</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>所以DCL和静态内部类等模式如果防止反序列化创建多个对象呢？答案是继承Serializable接口实现readResolve方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> implement Serializable <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span><span style=color:#f92672>(){}</span>
 
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingletonHoler</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton INSTANCE <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
    
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>return</span> SingletonHoler<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
	
	<span style=color:#66d9ef>private</span> Object <span style=color:#a6e22e>readResolve</span><span style=color:#f92672>(){</span>
		<span style=color:#66d9ef>return</span> SingletonHoler<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>;</span>
	<span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>为什么实现了readResolve方法就能防止反序列化创建多个对象呢？ObjectInputStream对象在反序列化的时候判断是否存在readResolve方法，如果存在则调用此方法进行创建。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>handles</span><span style=color:#f92672>.</span><span style=color:#a6e22e>lookupException</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>passHandle</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> desc<span style=color:#f92672>.</span><span style=color:#a6e22e>hasReadResolveMethod</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
    Object rep <span style=color:#f92672>=</span> desc<span style=color:#f92672>.</span><span style=color:#a6e22e>invokeReadResolve</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>unshared <span style=color:#f92672>&amp;&amp;</span> rep<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>isArray</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
        rep <span style=color:#f92672>=</span> cloneArray<span style=color:#f92672>(</span>rep<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>rep <span style=color:#f92672>!=</span> obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>rep <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>rep<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>isArray</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>filterCheck</span><span style=color:#f92672>(</span>rep<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>(),</span> Array<span style=color:#f92672>.</span><span style=color:#a6e22e>getLength</span><span style=color:#f92672>(</span>rep<span style=color:#f92672>));</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>filterCheck</span><span style=color:#f92672>(</span>rep<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>(),</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>

        obj <span style=color:#f92672>=</span> rep<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>handles</span><span style=color:#f92672>.</span><span style=color:#a6e22e>setObject</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>passHandle</span><span style=color:#f92672>,</span> rep<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=引申>引申</h2><p>从上面java的例子中可以看出单单一个单例模式就存在如此多的方式和坑，那么我们看看其他语言是怎么实现的？</p><h3 id=python>python</h3><p>python由于存在GIL（全局解释锁），即同一时刻只有一个线程在运行，所以当一个类使用import引入的时候就是单例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span>(object):
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(self):
        <span style=color:#66d9ef>pass</span>
singleton <span style=color:#f92672>=</span> Singleton()
<span style=color:#75715e># 从其他类import进来</span>
<span style=color:#f92672>from</span> foo <span style=color:#f92672>import</span> singleton
</code></pre></div><p>另外python中还支持通过函数装饰器，类装饰器，实现__new__和metaclass方式。其实前3中方式大同小异，都是拦截或者覆盖了new方法，创建出一个新的对象。至于metaclass则是创建类的方式，创建类的时候会调用new方式，当然是可以实现单例的。具体的代码不再赘述了。</p><h3 id=kotlin>kotlin</h3><p>kotlin几年前谷歌宣布作为安卓的官方开发语言后炙手可热，kotlin在语法上确实抛弃了java的一些历史包袱，采用了更加现代的语法，降低了编码时的心智负担。 我们来看下kotlin下DCL模式的实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>constructor</span>() {
    <span style=color:#66d9ef>companion</span> <span style=color:#66d9ef>object</span> {
        <span style=color:#66d9ef>val</span> instance: Singleton <span style=color:#66d9ef>by</span> lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {
        Singleton() }
    }
}
</code></pre></div><p>kotlin的语法更加简洁， 在语言设计上kotlin增加了不少语法糖来减少手动实现的难度，比如上面的lazy语法。另外kotlin官方也有一个简单的单例模式适合无参单例:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Singleton</span> {
  <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>sayHi</span>(){}
}
</code></pre></div><h3 id=js>js</h3><p>js一般认为是单进程单线程模型，所以单例模式写起来非常简单，更多的是结合js的语法使用闭包避免污染全局空间来实现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>singleton</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>fn</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>instance</span>;
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>() {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>instance</span> <span style=color:#f92672>||</span> (<span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#66d9ef>this</span>, <span style=color:#a6e22e>arguments</span>));
    }
};
</code></pre></div><p>结合es6的class语法糖也可以写出java饿汉式，但是没有java的线程安全问题，代码不再赘述。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>menguilin</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2020-11-28</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a>
<a href=/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/>单例模式</a></div><nav class=post-nav><a class=prev href=/post/2021/04/consensus-algorithm-study-notes-1/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">分布式协议与算法读书笔记（一）</span>
<span class="prev-text nav-mobile">上一篇</span></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=https://guilin.men/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>menguilin</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script><script type=text/javascript>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>